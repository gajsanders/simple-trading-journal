"""
Simple Trading Journal Application
A lightweight trading journal built with Streamlit for personal trade tracking.
"""

import os
import io
import json
import zipfile
import hashlib
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List

import numpy as np
import pandas as pd
import streamlit as st
import re

# ---------------------------
# Data model and constants
# ---------------------------

@dataclass
class Trade:
    """Data class representing a single trade."""
    date: str
    symbol: str
    strategy: str
    entry_price: float
    exit_price: float
    quantity: int
    pnl: float
    notes: str
    status: str

# Strategy options for the dropdown
STRATEGY_OPTIONS = [
    "Long Stock",
    "Short Stock",
    "Long Call",
    "Short Call",
    "Long Put",
    "Short Put",
    "Covered Call",
    "Cash Secured Put",
    "Other",
]

# Ensure data directory exists
DATA_DIR = "data"
TRADES_FILE = os.path.join(DATA_DIR, "trades.csv")
BACKUP_DIR = os.path.join(DATA_DIR, "backups")
CONFIG_FILE = os.path.join(DATA_DIR, "config.json")

class TradeValidationError(Exception):
    """Raised when trade data fails validation."""
    pass

class StorageError(Exception):
    """Raised when file operations fail."""
    pass

# ---------------------------
# Config
# ---------------------------

def load_config() -> dict:
    """
    Load application configuration.
    Returns:
        dict: Configuration dictionary
    """
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                return json.load(f)
        except Exception:
            pass
    # Default configuration
    return {
        "currency": "USD",
        "date_format": "YYYY-MM-DD",
        "default_strategy": "Long Stock",
        "theme": "light",
        "auto_save_interval": 300,  # 5 minutes
        "backup_enabled": True,
    }

def save_config(config: dict) -> None:
    """
    Save application configuration.
    Args:
        config (dict): Configuration dictionary
    """
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=2)
    except Exception as e:
        raise StorageError(f"Failed to save configuration: {str(e)}")

# ---------------------------
# Storage
# ---------------------------

@st.cache_data(ttl=300)  # Cache for 5 minutes
def load_trades() -> pd.DataFrame:
    """
    Load trades from CSV file.
    Returns:
        pd.DataFrame: DataFrame containing all trades
    """
    if os.path.exists(TRADES_FILE):
        try:
            return pd.read_csv(TRADES_FILE)
        except Exception as e:
            raise StorageError(f"Failed to load trades: {str(e)}")
    else:
        # Return empty DataFrame with correct columns
        return pd.DataFrame(columns=[
            "date", "symbol", "strategy", "entry_price",
            "exit_price", "quantity", "pnl", "notes", "status"
        ])

def save_trades(df: pd.DataFrame) -> None:
    """
    Save trades to CSV file.
    Args:
        df (pd.DataFrame): DataFrame containing all trades
    """
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        df.to_csv(TRADES_FILE, index=False)
    except Exception as e:
        raise StorageError(f"Failed to save trades: {str(e)}")

# ---------------------------
# P&L calculation and validation
# ---------------------------

def calculate_pnl(entry: float, exit: float, quantity: int, strategy: str = "Other") -> float:
    """
    Calculate profit/loss for a trade, accounting for options-specific logic.

    Options:
      - Sellers (Cash Secured Put, Covered Call, Short Put, Short Call):
        P&L = (credit received - debit paid) * |contracts| * 100
      - Buyers (Long Put, Long Call):
        P&L = (credit received - debit paid) * |contracts| * 100 = (exit - entry) * |contracts| * 100
    Stocks/Other:
      - P&L = (exit - entry) * quantity
    """
    try:
        entry = float(entry)
        exit = float(exit)
        qty = int(quantity)
    except Exception:
        return 0.0

    sell_opts = {"Cash Secured Put", "Covered Call", "Short Put", "Short Call"}
    buy_opts = {"Long Put", "Long Call"}

    if strategy in sell_opts or strategy in buy_opts:
        contracts = abs(qty)
        multiplier = 100
        if strategy in sell_opts:
            return (entry - exit) * contracts * multiplier
        else:
            return (exit - entry) * contracts * multiplier

    # Stocks/other
    return (exit - entry) * qty

def validate_trade_data(trade_data: dict) -> None:
    """
    Validate trade data.
    Args:
        trade_data (dict): Dictionary containing trade information
    Raises:
        TradeValidationError: If validation fails
    """
    # Validate required fields
    if not trade_data.get('symbol'):
        raise TradeValidationError("Symbol is required")
    if not trade_data.get('strategy'):
        raise TradeValidationError("Strategy is required")

    # Validate numeric fields
    try:
        entry_price = float(trade_data.get('entry_price', 0))
        if entry_price <= 0:
            raise TradeValidationError("Entry price must be positive")
    except (ValueError, TypeError):
        raise TradeValidationError("Entry price must be a valid number")

    try:
        quantity = int(trade_data.get('quantity', 0))
        if quantity == 0:
            raise TradeValidationError("Quantity cannot be zero")
    except (ValueError, TypeError):
        raise TradeValidationError("Quantity must be a valid integer")

    # Validate exit price if provided
    exit_price = trade_data.get('exit_price', 0)
    if exit_price:
        try:
            float(exit_price)
        except (ValueError, TypeError):
            raise TradeValidationError("Exit price must be a valid number")

    # Minimal business rules; keep option selling flexible
    strategy = str(trade_data.get('strategy', ''))
    quantity = int(trade_data.get('quantity', 0))
    if strategy == "Short Stock" and quantity > 0:
        raise TradeValidationError("Short Stock requires negative quantity")
    if strategy in ["Long Stock", "Long Call", "Long Put"] and quantity < 0:
        raise TradeValidationError(f"{strategy} requires positive quantity")

# ---------------------------
# Stats and add trade
# ---------------------------

def get_summary_stats(df: pd.DataFrame) -> Dict[str, float]:
    """
    Calculate summary statistics from trades.
    Args:
        df (pd.DataFrame): DataFrame containing trades
    Returns:
        dict: Dictionary with summary statistics
    """
    if df.empty:
        return {'total_pnl': 0.0, 'win_rate': 0.0, 'total_trades': 0, 'avg_trade': 0.0}

    closed_trades = df[df['status'] == 'Closed']
    if closed_trades.empty:
        return {'total_pnl': 0.0, 'win_rate': 0.0, 'total_trades': len(df), 'avg_trade': 0.0}

    total_pnl = closed_trades['pnl'].sum()
    winning_trades = len(closed_trades[closed_trades['pnl'] > 0])
    total_closed_trades = len(closed_trades)
    win_rate = winning_trades / total_closed_trades if total_closed_trades > 0 else 0
    avg_trade = closed_trades['pnl'].mean() if total_closed_trades > 0 else 0

    return {
        'total_pnl': total_pnl,
        'win_rate': win_rate,
        'total_trades': len(df),
        'avg_trade': avg_trade,
    }

def add_trade(trade_data: dict) -> None:
    """
    Add a new trade to the database.
    Args:
        trade_data (dict): Dictionary containing trade information
    """
    validate_trade_data(trade_data)
    df = load_trades()

    # Determine status first (support Closed even if exit is 0, e.g., expired worthless)
    status = trade_data.get('status')
    if status not in ("Open", "Closed"):
        status = 'Closed' if trade_data.get('exit_price', 0) > 0 else 'Open'
    trade_data['status'] = status

    # Compute realized P&L only when Closed
    if trade_data['status'] == 'Closed':
        trade_data['pnl'] = calculate_pnl(
            trade_data['entry_price'],
            trade_data['exit_price'],
            trade_data['quantity'],
            trade_data.get('strategy', 'Other')
        )
    else:
        trade_data['pnl'] = 0.0

    # Append and save
    new_trade_df = pd.DataFrame([trade_data])
    df = pd.concat([df, new_trade_df], ignore_index=True)
    save_trades(df)

# ---------------------------
# Filtering and charts
# ---------------------------

def filter_trades(trades_df: pd.DataFrame, filter_config: dict) -> pd.DataFrame:
    """
    Apply filters to the trades DataFrame.
    Args:
        trades_df (pd.DataFrame): DataFrame containing all trades
        filter_config (dict): Dictionary containing filter settings
    Returns:
        pd.DataFrame: Filtered DataFrame
    """
    if trades_df.empty:
        return trades_df

    filtered_df = trades_df.copy()

    # Date range filter
    if filter_config.get('start_date') and filter_config.get('end_date'):
        filtered_df = filtered_df[
            (filtered_df['date'] >= filter_config['start_date']) &
            (filtered_df['date'] <= filter_config['end_date'])
        ]

    # Symbol filter
    if filter_config.get('symbols'):
        filtered_df = filtered_df[filtered_df['symbol'].isin(filter_config['symbols'])]

    # Strategy filter
    if filter_config.get('strategies'):
        filtered_df = filtered_df[filtered_df['strategy'].isin(filter_config['strategies'])]

    # Status filter
    if filter_config.get('statuses'):
        filtered_df = filtered_df[filtered_df['status'].isin(filter_config['statuses'])]

    # PnL range filter
    if filter_config.get('min_pnl') is not None and filter_config.get('max_pnl') is not None:
        filtered_df = filtered_df[
            (filtered_df['pnl'] >= filter_config['min_pnl']) &
            (filtered_df['pnl'] <= filter_config['max_pnl'])
        ]

    # Text search filter
    if filter_config.get('search_text'):
        search_text = filter_config['search_text'].lower()
        filtered_df = filtered_df[
            filtered_df['symbol'].str.lower().str.contains(search_text, na=False) |
            filtered_df['notes'].str.lower().str.contains(search_text, na=False)
        ]

    return filtered_df

def create_filter_sidebar(trades_df: pd.DataFrame) -> dict:
    """
    Create sidebar filter controls and return filter configuration.
    Args:
        trades_df (pd.DataFrame): DataFrame containing all trades
    Returns:
        dict: Filter configuration
    """
    filter_config = {}
    st.sidebar.header("üîç Filters")

    # Date range filter
    st.sidebar.subheader("Date Range")
    col1, col2 = st.sidebar.columns(2)
    default_end_date = datetime.now().date()
    default_start_date = default_end_date - timedelta(days=30)

    with col1:
        start_date = st.sidebar.date_input("Start Date", value=default_start_date, key="start_date")

    with col2:
        end_date = st.sidebar.date_input("End Date", value=default_end_date, key="end_date")

    filter_config['start_date'] = start_date.strftime("%Y-%m-%d")
    filter_config['end_date'] = end_date.strftime("%Y-%m-%d")

    preset = st.sidebar.selectbox(
        "Date Presets",
        ["Custom", "Last 7 Days", "Last 30 Days", "This Month", "This Year", "All Time"]
    )

    today = datetime.now().date()
    if preset == "Last 7 Days":
        filter_config['start_date'] = (today - timedelta(days=7)).strftime("%Y-%m-%d")
    elif preset == "Last 30 Days":
        filter_config['start_date'] = (today - timedelta(days=30)).strftime("%Y-%m-%d")
    elif preset == "This Month":
        filter_config['start_date'] = today.replace(day=1).strftime("%Y-%m-%d")
    elif preset == "This Year":
        filter_config['start_date'] = today.replace(month=1, day=1).strftime("%Y-%m-%d")
    elif preset == "All Time":
        filter_config['start_date'] = "1900-01-01"

    # Symbol filter
    if not trades_df.empty:
        all_symbols = sorted(trades_df['symbol'].astype(str).unique())
        selected_symbols = st.sidebar.multiselect("Symbols", all_symbols, key="symbol_filter")
        if selected_symbols:
            filter_config['symbols'] = selected_symbols

    # Strategy filter
    selected_strategies = st.sidebar.multiselect("Strategies", STRATEGY_OPTIONS, key="strategy_filter")
    if selected_strategies:
        filter_config['strategies'] = selected_strategies

    # Status filter
    status_options = ["Open", "Closed"]
    selected_statuses = st.sidebar.multiselect("Status", status_options, default=status_options, key="status_filter")
    if selected_statuses:
        filter_config['statuses'] = selected_statuses

    # PnL range filter
    st.sidebar.subheader("P&L Range")
    c1, c2 = st.sidebar.columns(2)
    with c1:
        min_pnl = st.sidebar.number_input("Min P&L", value=-10000.0, step=100.0, key="min_pnl")
    with c2:
        max_pnl = st.sidebar.number_input("Max P&L", value=10000.0, step=100.0, key="max_pnl")
    filter_config['min_pnl'] = float(min_pnl)
    filter_config['max_pnl'] = float(max_pnl)

    # Text search
    search_text = st.sidebar.text_input("Search Symbols/Notes", key="search_text")
    if search_text:
        filter_config['search_text'] = search_text

    # Clear filters button
    if st.sidebar.button("Clear All Filters"):
        st.session_state.clear()
        st.rerun()

    return filter_config

def get_pnl_over_time(trades_df: pd.DataFrame) -> pd.DataFrame:
    """
    Prepare data for P&L over time chart.
    Returns DataFrame with columns: date, pnl (daily), cumulative_pnl
    """
    if trades_df.empty:
        return pd.DataFrame(columns=['date', 'pnl', 'cumulative_pnl'])

    closed_trades = trades_df[trades_df['status'] == 'Closed'].copy()
    if closed_trades.empty:
        return pd.DataFrame(columns=['date', 'pnl', 'cumulative_pnl'])

    closed_trades['date'] = pd.to_datetime(closed_trades['date'])
    daily = closed_trades.groupby('date')['pnl'].sum().reset_index().sort_values('date')
    daily['cumulative_pnl'] = daily['pnl'].cumsum()
    return daily

def get_win_loss_distribution(trades_df: pd.DataFrame) -> pd.DataFrame:
    """
    Prepare data for win/loss distribution chart.
    """
    if trades_df.empty:
        return pd.DataFrame(columns=['category', 'count'])

    closed_trades = trades_df[trades_df['status'] == 'Closed']
    if closed_trades.empty:
        return pd.DataFrame(columns=['category', 'count'])

    wins = len(closed_trades[closed_trades['pnl'] > 0])
    losses = len(closed_trades[closed_trades['pnl'] < 0])
    breakeven = len(closed_trades[closed_trades['pnl'] == 0])

    return pd.DataFrame({'category': ['Wins', 'Losses', 'Breakeven'], 'count': [wins, losses, breakeven]})

def get_strategy_performance(trades_df: pd.DataFrame) -> pd.DataFrame:
    """
    Prepare data for strategy performance chart.
    """
    if trades_df.empty:
        return pd.DataFrame(columns=['strategy', 'total_pnl', 'avg_pnl'])

    closed_trades = trades_df[trades_df['status'] == 'Closed']
    if closed_trades.empty:
        return pd.DataFrame(columns=['strategy', 'total_pnl', 'avg_pnl'])

    strategy_perf = closed_trades.groupby('strategy').agg({'pnl': ['sum', 'mean', 'count']}).reset_index()
    strategy_perf.columns = ['strategy', 'total_pnl', 'avg_pnl', 'trade_count']
    return strategy_perf[['strategy', 'total_pnl', 'avg_pnl']]

def get_monthly_summary(trades_df: pd.DataFrame) -> pd.DataFrame:
    """
    Prepare data for monthly performance chart.
    """
    if trades_df.empty:
        return pd.DataFrame(columns=['month', 'pnl'])

    closed_trades = trades_df[trades_df['status'] == 'Closed'].copy()
    if closed_trades.empty:
        return pd.DataFrame(columns=['month', 'pnl'])

    closed_trades['date'] = pd.to_datetime(closed_trades['date'])
    closed_trades['month'] = closed_trades['date'].dt.to_period('M').astype(str)
    monthly_perf = closed_trades.groupby('month')['pnl'].sum().reset_index()
    return monthly_perf

def display_charts(trades_df: pd.DataFrame) -> None:
    """
    Display charts for trade analysis.
    """
    if trades_df.empty:
        st.info("No data available for charts. Add some trades to see visualizations.")
        return

    closed_trades = trades_df[trades_df['status'] == 'Closed']
    if closed_trades.empty:
        st.info("No closed trades available for charts. Close some trades to see visualizations.")
        return

    st.subheader("üìä Performance Charts")

    tab1, tab2, tab3, tab4 = st.tabs(["P&L Over Time", "Win/Loss Distribution", "Strategy Performance", "Monthly Performance"])

    with tab1:
        st.write("### Cumulative P&L Over Time")
        pnl_data = get_pnl_over_time(trades_df)
        if not pnl_data.empty:
            st.line_chart(pnl_data.set_index('date')['cumulative_pnl'], height=400)
            st.write("### Daily P&L")
            st.bar_chart(pnl_data.set_index('date')['pnl'], height=300)
        else:
            st.info("No closed trades available for P&L chart.")

    with tab2:
        st.write("### Win/Loss Distribution")
        win_loss_data = get_win_loss_distribution(trades_df)
        if not win_loss_data.empty:
            st.bar_chart(win_loss_data.set_index('category')['count'], height=400)
        else:
            st.info("No closed trades available for win/loss distribution.")

    with tab3:
        st.write("### Strategy Performance")
        strategy_data = get_strategy_performance(trades_df)
        if not strategy_data.empty:
            st.bar_chart(strategy_data.set_index('strategy')['total_pnl'], height=400)
        else:
            st.info("No closed trades available for strategy performance chart.")

    with tab4:
        st.write("### Monthly Performance")
        monthly_data = get_monthly_summary(trades_df)
        if not monthly_data.empty:
            st.bar_chart(monthly_data.set_index('month')['pnl'], height=400)
        else:
            st.info("No closed trades available for monthly performance chart.")

# ---------------------------
# CSV analysis & import
# ---------------------------

def analyze_csv(uploaded_file) -> dict:
    """
    Analyze CSV structure and suggest column mappings.
    """
    try:
        df = pd.read_csv(uploaded_file, nrows=10)
        uploaded_file.seek(0)
    except Exception as e:
        st.error(f"Error reading CSV file: {str(e)}")
        return {}

    csv_columns = df.columns.tolist()

    # Detect Tastytrade-like
    is_tastytrade = all(col in csv_columns for col in ["Symbol", "Price", "Description"])

    # Required trade fields
    required_fields = ["date", "symbol", "strategy", "entry_price", "exit_price", "quantity", "pnl", "notes", "status"]

    suggested_mappings = {}
    if is_tastytrade:
        suggested_mappings = {
            "symbol": "Symbol",
            "entry_price": "Price",
            "notes": "Description",
            "status": "Status",
        }
    else:
        field_variations = {
            "date": ["date", "trade_date", "entry_date", "timestamp"],
            "symbol": ["symbol", "ticker", "stock", "instrument"],
            "strategy": ["strategy", "strat", "approach"],
            "entry_price": ["entry_price", "entry", "buy_price", "purchase_price", "credit"],
            "exit_price": ["exit_price", "sell_price", "sale_price", "close_price", "debit"],
            "quantity": ["quantity", "qty", "shares", "contracts", "size"],
            "pnl": ["pnl", "profit", "loss", "gain"],
            "notes": ["notes", "comment", "description", "remarks"],
            "status": ["status", "state"],
        }
        for field in required_fields:
            for col in csv_columns:
                if col.lower() in field_variations.get(field, []):
                    suggested_mappings[field] = col
                    break

    return {
        "columns": csv_columns,
        "sample_data": df.head(),
        "suggested_mappings": suggested_mappings,
        "row_count": len(df),
        "is_tastytrade": is_tastytrade,
    }

def validate_import_data(df: pd.DataFrame) -> List[str]:
    """
    Validate import data and return any errors.
    """
    errors = []
    required_columns = ["date", "symbol", "strategy", "entry_price", "quantity"]
    for col in required_columns:
        if col not in df.columns:
            errors.append(f"Missing required column: {col}")
    if errors:
        return errors

    for idx, row in df.iterrows():
        # Validate date format
        try:
            pd.to_datetime(row['date'])
        except Exception:
            errors.append(f"Row {idx+1}: Invalid date format '{row['date']}'")
        # Validate symbol
        if pd.isna(row['symbol']) or str(row['symbol']).strip() == "":
            errors.append(f"Row {idx+1}: Missing symbol")
        # Validate strategy
        if row['strategy'] not in STRATEGY_OPTIONS:
            errors.append(f"Row {idx+1}: Invalid strategy '{row['strategy']}'")
        # Validate entry price
        try:
            entry_price = float(row['entry_price'])
            if entry_price <= 0:
                errors.append(f"Row {idx+1}: Entry price must be positive")
        except Exception:
            errors.append(f"Row {idx+1}: Invalid entry price '{row['entry_price']}'")
        # Validate quantity
        try:
            quantity = int(row['quantity'])
            if quantity == 0:
                errors.append(f"Row {idx+1}: Quantity cannot be zero")
        except Exception:
            errors.append(f"Row {idx+1}: Invalid quantity '{row['quantity']}'")
        # Validate exit price if present
        if 'exit_price' in row and not pd.isna(row['exit_price']):
            try:
                float(row['exit_price'])
            except Exception:
                errors.append(f"Row {idx+1}: Invalid exit price '{row['exit_price']}'")

    return errors

def import_trades(uploaded_file, column_mapping: dict, skip_duplicates: bool = False) -> dict:
    """
    Import trades from CSV file.
    """
    try:
        df = pd.read_csv(uploaded_file)
    except Exception as e:
        return {"success": False, "error": f"Error reading CSV file: {str(e)}"}

    is_tastytrade = "Symbol" in df.columns and "Price" in df.columns and "Description" in df.columns
    if is_tastytrade:
        return import_tastytrade_trades(df, skip_duplicates)

    # Apply column mapping for standard format
    mapped_df = pd.DataFrame()
    for trade_field, csv_column in column_mapping.items():
        if csv_column in df.columns:
            mapped_df[trade_field] = df[csv_column]
        else:
            if trade_field == "exit_price":
                mapped_df[trade_field] = 0.0
            elif trade_field == "notes":
                mapped_df[trade_field] = ""
            elif trade_field == "pnl":
                mapped_df[trade_field] = 0.0
            elif trade_field == "status":
                mapped_df[trade_field] = "Open"
            else:
                mapped_df[trade_field] = None

    # Validate data
    validation_errors = validate_import_data(mapped_df)
    if validation_errors:
        return {"success": False, "error": "Validation errors found", "validation_errors": validation_errors}

    # Clean and normalize data
    try:
        mapped_df['date'] = pd.to_datetime(mapped_df['date']).dt.strftime('%Y-%m-%d')
        mapped_df['entry_price'] = pd.to_numeric(mapped_df['entry_price'])
        mapped_df['quantity'] = pd.to_numeric(mapped_df['quantity'])
        if 'exit_price' in mapped_df.columns:
            mapped_df['exit_price'] = pd.to_numeric(mapped_df['exit_price'], errors='coerce').fillna(0.0)
        else:
            mapped_df['exit_price'] = 0.0

        # Normalize symbol
        mapped_df['symbol'] = mapped_df['symbol'].astype(str).upper().str.strip()

        # Notes
        if 'notes' in mapped_df.columns:
            mapped_df['notes'] = mapped_df['notes'].fillna("").astype(str)
        else:
            mapped_df['notes'] = ""

        # Status first (honor input if valid)
        if 'status' in mapped_df.columns:
            mapped_df['status'] = mapped_df['status'].astype(str).str.title()
            mapped_df.loc[~mapped_df['status'].isin(['Open', 'Closed']), 'status'] = 'Open'
        else:
            # Conservative fallback; don't force exit>0 means Closed; users can close later
            mapped_df['status'] = np.where(mapped_df['exit_price'] > 0, 'Closed', 'Open')

        # Compute PnL for Closed only
        mapped_df['pnl'] = mapped_df.apply(
            lambda row: calculate_pnl(row['entry_price'], row['exit_price'], row['quantity'], row.get('strategy', 'Other'))
            if row['status'] == 'Closed' else 0.0,
            axis=1
        )

    except Exception as e:
        return {"success": False, "error": f"Error processing data: {str(e)}"}

    # Load existing trades
    existing_trades = load_trades()

    # Duplicates
    if skip_duplicates and not existing_trades.empty:
        mapped_df['duplicate_key'] = mapped_df.apply(
            lambda row: f"{row['date']}_{row['symbol']}_{row['entry_price']}", axis=1
        )
        existing_trades['duplicate_key'] = existing_trades.apply(
            lambda row: f"{row['date']}_{row['symbol']}_{row['entry_price']}", axis=1
        )
        original_count = len(mapped_df)
        mapped_df = mapped_df[~mapped_df['duplicate_key'].isin(existing_trades['duplicate_key'])]
        duplicate_count = original_count - len(mapped_df)
        mapped_df = mapped_df.drop('duplicate_key', axis=1)
        existing_trades = existing_trades.drop('duplicate_key', axis=1)
    else:
        duplicate_count = 0

    # Combine and save
    if existing_trades.empty:
        combined_df = mapped_df
    else:
        combined_df = pd.concat([existing_trades, mapped_df], ignore_index=True)

    try:
        save_trades(combined_df)
        return {
            "success": True,
            "imported_count": len(mapped_df),
            "duplicate_count": duplicate_count,
            "total_count": len(combined_df),
        }
    except Exception as e:
        return {"success": False, "error": f"Error saving trades: {str(e)}"}

def import_tastytrade_trades(df: pd.DataFrame, skip_duplicates: bool = False) -> dict:
    """
    Import trades from Tastytrade CSV format.
    """
    try:
        processed_trades = []
        for idx, row in df.iterrows():
            try:
                trade_data = parse_tastytrade_row(row)
                if trade_data:
                    processed_trades.append(trade_data)
            except Exception as e:
                st.warning(f"Skipping row {idx+1} due to parsing error: {str(e)}")
                continue

        if not processed_trades:
            return {"success": False, "error": "No valid trades found in the file"}

        mapped_df = pd.DataFrame(processed_trades)

        # Status first
        if 'status' in mapped_df.columns:
            mapped_df['status'] = mapped_df['status'].astype(str).str.title()
            mapped_df.loc[~mapped_df['status'].isin(['Open', 'Closed']), 'status'] = 'Open'
        else:
            mapped_df['status'] = np.where(mapped_df['exit_price'] > 0, 'Closed', 'Open')

        # Compute P&L for Closed only
        mapped_df['pnl'] = mapped_df.apply(
            lambda row: calculate_pnl(row['entry_price'], row['exit_price'], row['quantity'], row.get('strategy', 'Other'))
            if row['status'] == 'Closed' else 0.0,
            axis=1
        )

        # Validate
        validation_errors = validate_import_data(mapped_df)
        if validation_errors:
            return {"success": False, "error": "Validation errors found", "validation_errors": validation_errors}

        # Load existing
        existing_trades = load_trades()

        # Duplicates
        if skip_duplicates and not existing_trades.empty:
            mapped_df['duplicate_key'] = mapped_df.apply(
                lambda row: f"{row['date']}_{row['symbol']}_{row['entry_price']}", axis=1
            )
            existing_trades['duplicate_key'] = existing_trades.apply(
                lambda row: f"{row['date']}_{row['symbol']}_{row['entry_price']}", axis=1
            )
            original_count = len(mapped_df)
            mapped_df = mapped_df[~mapped_df['duplicate_key'].isin(existing_trades['duplicate_key'])]
            duplicate_count = original_count - len(mapped_df)
            mapped_df = mapped_df.drop('duplicate_key', axis=1)
            existing_trades = existing_trades.drop('duplicate_key', axis=1)
        else:
            duplicate_count = 0

        # Combine and save
        if existing_trades.empty:
            combined_df = mapped_df
        else:
            combined_df = pd.concat([existing_trades, mapped_df], ignore_index=True)

        save_trades(combined_df)
        return {
            "success": True,
            "imported_count": len(mapped_df),
            "duplicate_count": duplicate_count,
            "total_count": len(combined_df),
        }

    except Exception as e:
        return {"success": False, "error": f"Error processing Tastytrade data: {str(e)}"}

def parse_tastytrade_row(row) -> dict:
    """
    Parse a single row from Tastytrade CSV format.
    """
    try:
        symbol = str(row.get('Symbol', '')).upper().strip()
        if not symbol:
            return None

        price_str = str(row.get('Price', ''))
        price_parts = price_str.split()
        if price_parts:
            price_clean = ''.join(c for c in price_parts if c.isdigit() or c == '.')
            if price_clean:
                price = float(price_clean)
            else:
                return None
        else:
            return None

        description = str(row.get('Description', ''))
        status_text = str(row.get('Status', ''))
        time_info = str(row.get('Time', '')) or str(row.get('TimeStampAtType', ''))

        # Basic default date; improve parsing if actual timestamp available
        date = datetime.now().strftime('%Y-%m-%d')

        # Quantity: simple integer scan
        qty = 1
        qty_match = re.search(r'([+-]?\d+)', description)
        if qty_match:
            qty = int(qty_match.group(1))

        entry_price = price
        exit_price = 0.0
        trade_status = 'Open'
        if 'STC' in description or 'BTC' in description:
            trade_status = 'Closed'
            exit_price = entry_price  # Simplified; real fill pairing would differ

        # Determine strategy heuristically
        strategy = 'Other'
        if 'Put' in description:
            if 'STO' in description:
                strategy = 'Cash Secured Put'
            elif 'BTC' in description:
                strategy = 'Long Put'
            elif 'BTO' in description:
                strategy = 'Long Put'
            elif 'STC' in description:
                strategy = 'Cash Secured Put'
            else:
                strategy = 'Long Put' if qty > 0 else 'Cash Secured Put'
        elif 'Call' in description:
            if 'STO' in description:
                strategy = 'Covered Call'
            elif 'BTC' in description:
                strategy = 'Long Call'
            elif 'BTO' in description:
                strategy = 'Long Call'
            elif 'STC' in description:
                strategy = 'Covered Call'
            else:
                strategy = 'Long Call' if qty > 0 else 'Covered Call'
        elif any(word in description for word in ['Stock', 'Equity']):
            strategy = 'Long Stock' if qty > 0 else 'Short Stock'
        else:
            strategy = 'Long Stock' if qty > 0 else 'Short Stock'

        return {
            'date': date,
            'symbol': symbol,
            'strategy': strategy,
            'entry_price': entry_price,
            'exit_price': exit_price,
            'quantity': qty,
            'pnl': 0.0,
            'notes': description,
            'status': trade_status,
        }
    except Exception:
        return None

# ---------------------------
# Export, backup, restore
# ---------------------------

def export_to_csv(trades_df: pd.DataFrame, include_metrics: bool = False) -> bytes:
    """
    Export trades to CSV format.
    """
    if include_metrics and not trades_df.empty:
        export_df = trades_df.copy()
        if {'entry_price', 'exit_price', 'quantity', 'strategy'}.issubset(export_df.columns):
            export_df['calculated_pnl'] = export_df.apply(
                lambda row: calculate_pnl(row['entry_price'], row['exit_price'], row['quantity'], row.get('strategy', 'Other')),
                axis=1
            )
        export_df['exported_at'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        csv_data = export_df.to_csv(index=False)
    else:
        csv_data = trades_df.to_csv(index=False)
    return csv_data.encode('utf-8')

def export_summary_report(trades_df: pd.DataFrame) -> str:
    """
    Generate a text summary report of trades.
    """
    if trades_df.empty:
        return "No trades to report."

    stats = get_summary_stats(trades_df)
    closed_trades = trades_df[trades_df['status'] == 'Closed']
    open_trades = trades_df[trades_df['status'] == 'Open']

    largest_win = 0.0
    largest_loss = 0.0
    if not closed_trades.empty:
        largest_win = closed_trades['pnl'].max()
        largest_loss = closed_trades['pnl'].min()

    report = f"""
TRADE JOURNAL SUMMARY REPORT
============================
Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

OVERALL PERFORMANCE
-------------------
Total P&L: ${stats['total_pnl']:.2f}
Win Rate: {stats['win_rate']:.1%}
Total Trades: {stats['total_trades']}
Average Trade: ${stats['avg_trade']:.2f}

TRADE BREAKDOWN
---------------
Closed Trades: {len(closed_trades)}
Open Trades: {len(open_trades)}
Largest Win: ${largest_win:.2f}
Largest Loss: ${largest_loss:.2f}

STRATEGY PERFORMANCE
--------------------
"""
    strategy_perf = get_strategy_performance(trades_df)
    if not strategy_perf.empty:
        for _, row in strategy_perf.iterrows():
            report += f"{row['strategy']}: ${row['total_pnl']:.2f} (avg: ${row['avg_pnl']:.2f})\n"

    if not closed_trades.empty:
        top_symbols = closed_trades.groupby('symbol')['pnl'].sum().sort_values(ascending=False).head(5)
        report += "\nTOP PERFORMING SYMBOLS\n"
        report += "----------------------\n"
        for symbol, pnl in top_symbols.items():
            report += f"{symbol}: ${pnl:.2f}\n"

    return report

def create_backup() -> str:
    """
    Create a timestamped backup of the trades file.
    Returns:
        str: Path to backup file
    """
    trades_df = load_trades()
    os.makedirs(BACKUP_DIR, exist_ok=True)
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    backup_filename = f"trades_backup_{timestamp}.csv"
    backup_path = os.path.join(BACKUP_DIR, backup_filename)
    trades_df.to_csv(backup_path, index=False)
    return backup_path

def get_backup_files() -> List[str]:
    """
    Get list of available backup files.
    """
    if not os.path.exists(BACKUP_DIR):
        return []
    backup_files = []
    for file in os.listdir(BACKUP_DIR):
        if file.startswith("trades_backup_") and file.endswith(".csv"):
            backup_files.append(os.path.join(BACKUP_DIR, file))
    backup_files.sort(key=lambda x: os.path.getmtime(x), reverse=True)
    return backup_files

def restore_from_backup(backup_path: str) -> bool:
    """
    Restore trades from a backup file.
    """
    try:
        if not os.path.exists(backup_path):
            return False
        backup_df = pd.read_csv(backup_path)
        save_trades(backup_df)
        return True
    except Exception as e:
        st.error(f"Error restoring from backup: {str(e)}")
        return False

# ---------------------------
# UI sections
# ---------------------------

def display_import_section() -> None:
    """
    CSV import UI.
    """
    st.subheader("üìÅ CSV Import")
    uploaded_file = st.file_uploader("Upload CSV File", type="csv", key="csv_uploader")
    if uploaded_file is not None:
        analysis = analyze_csv(uploaded_file)
        if analysis:
            st.write(f"**File Info:** {analysis['row_count']} rows, {len(analysis['columns'])} columns")
            if analysis.get('is_tastytrade', False):
                st.info("‚úÖ Detected Tastytrade CSV format")
            st.write("**Sample Data:**")
            st.dataframe(analysis['sample_data'])

            st.write("**Column Mapping:**")
            if analysis.get('is_tastytrade', False):
                st.info("Tastytrade format detected. We'll automatically map the columns and parse the trade details.")
                column_mapping = {}
            else:
                column_mapping = {}
                required_fields = ["date", "symbol", "strategy", "entry_price", "quantity"]
                optional_fields = ["exit_price", "notes", "status"]
                for field in required_fields + optional_fields:
                    default_value = analysis['suggested_mappings'].get(field, "")
                    selected_column = st.selectbox(
                        f"{field}{'*' if field in required_fields else ''}",
                        [""] + analysis['columns'],
                        index=analysis['columns'].index(default_value) + 1 if default_value in analysis['columns'] else 0,
                        key=f"mapping_{field}"
                    )
                    if selected_column:
                        column_mapping[field] = selected_column

            st.write("**Import Options:**")
            skip_duplicates = st.checkbox("Skip duplicate trades", value=True)

            if st.button("Preview Mapped Data"):
                try:
                    uploaded_file.seek(0)
                    df = pd.read_csv(uploaded_file)
                    if analysis.get('is_tastytrade', False):
                        sample_trades = []
                        for idx, row in df.head(5).iterrows():
                            try:
                                trade_data = parse_tastytrade_row(row)
                                if trade_data:
                                    sample_trades.append(trade_data)
                            except:
                                continue
                        if sample_trades:
                            mapped_df = pd.DataFrame(sample_trades)
                            st.write("**Mapped Data Preview (Tastytrade format):**")
                            st.dataframe(mapped_df)
                            validation_errors = validate_import_data(mapped_df)
                            if validation_errors:
                                st.warning("**Validation Errors Found:**")
                                for error in validation_errors:
                                    st.write(f"- {error}")
                            else:
                                st.success("Data validation passed!")
                        else:
                            st.warning("Unable to parse any trades from the Tastytrade data.")
                    else:
                        mapped_df = pd.DataFrame()
                        for trade_field, csv_column in column_mapping.items():
                            if csv_column and csv_column in df.columns:
                                mapped_df[trade_field] = df[csv_column]
                        st.write("**Mapped Data Preview:**")
                        st.dataframe(mapped_df)
                        validation_errors = validate_import_data(mapped_df)
                        if validation_errors:
                            st.warning("**Validation Errors Found:**")
                            for error in validation_errors:
                                st.write(f"- {error}")
                        else:
                            st.success("Data validation passed!")
                except Exception as e:
                    st.error(f"Error previewing data: {str(e)}")

            if st.button("Import Trades"):
                try:
                    uploaded_file.seek(0)
                    result = import_trades(uploaded_file, column_mapping, skip_duplicates)
                    if result["success"]:
                        st.success(
                            f"Successfully imported {result['imported_count']} trades! "
                            f"({result['duplicate_count']} duplicates skipped)"
                        )
                        st.rerun()
                    else:
                        st.error(f"Import failed: {result['error']}")
                        if "validation_errors" in result:
                            st.write("**Validation Errors:**")
                            for error in result["validation_errors"]:
                                st.write(f"- {error}")
                except Exception as e:
                    st.error(f"Error during import: {str(e)}")
    else:
        template_data = pd.DataFrame(columns=[
            "date", "symbol", "strategy", "entry_price", "exit_price", "quantity", "notes", "status"
        ])
        template_csv = template_data.to_csv(index=False)
        st.write("**Need a template?** Download this CSV template to get started:")
        st.download_button(label="Download CSV Template", data=template_csv, file_name="trades_template.csv", mime="text/csv")

def display_export_section(trades_df: pd.DataFrame, filtered_trades_df: pd.DataFrame) -> None:
    """
    Export UI.
    """
    st.subheader("üíæ Export Data")
    tab1, tab2, tab3 = st.tabs(["CSV Export", "Summary Report", "Backup/Restore"])

    with tab1:
        st.write("### CSV Export Options")
        export_type = st.radio("Export Type", ["All Trades", "Filtered Trades"], key="export_type")
        include_metrics = st.checkbox("Include calculated metrics", value=False)
        data_to_export = trades_df if export_type == "All Trades" else filtered_trades_df
        if not data_to_export.empty:
            csv_data = export_to_csv(data_to_export, include_metrics)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"trades_export_{timestamp}.csv"
            st.download_button(label="Download CSV", data=csv_data, file_name=filename, mime="text/csv")
        else:
            st.info("No trades to export.")

    with tab2:
        st.write("### Summary Report")
        report = export_summary_report(trades_df)
        st.text_area("Report Preview", report, height=400)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        report_filename = f"trade_summary_{timestamp}.txt"
        st.download_button(label="Download Summary Report", data=report, file_name=report_filename, mime="text/plain")

    with tab3:
        st.write("### Backup and Restore")
        if st.button("Create Backup"):
            try:
                backup_path = create_backup()
                st.success(f"Backup created successfully: {os.path.basename(backup_path)}")
            except Exception as e:
                st.error(f"Error creating backup: {str(e)}")

        backup_files = get_backup_files()
        if backup_files:
            st.write("**Available Backups:**")
            backup_data = []
            for backup_file in backup_files:
                filename = os.path.basename(backup_file)
                mod_time = datetime.fromtimestamp(os.path.getmtime(backup_file))
                size = os.path.getsize(backup_file)
                backup_data.append({"Filename": filename, "Date": mod_time.strftime('%Y-%m-%d %H:%M:%S'), "Size (KB)": round(size / 1024, 2)})
            backup_df = pd.DataFrame(backup_data)
            st.dataframe(backup_df)

            st.write("**Restore from Backup:**")
            selected_backup = st.selectbox("Select backup to restore", [os.path.basename(f) for f in backup_files], key="backup_select")
            if st.button("Restore Selected Backup"):
                selected_path = os.path.join(BACKUP_DIR, selected_backup)
                if restore_from_backup(selected_path):
                    st.success("Backup restored successfully!")
                    st.rerun()
                else:
                    st.error("Failed to restore backup.")
        else:
            st.info("No backups available.")

def display_data_management_section(trades_df: pd.DataFrame) -> None:
    """
    Data management UI.
    """
    st.subheader("‚öôÔ∏è Data Management")
    if trades_df.empty:
        st.info("No trades to manage.")
        return

    st.write("### Data Statistics")
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.metric("Total Trades", len(trades_df))
    with col2:
        closed_trades = trades_df[trades_df['status'] == 'Closed']
        st.metric("Closed Trades", len(closed_trades))
    with col3:
        open_trades = trades_df[trades_df['status'] == 'Open']
        st.metric("Open Trades", len(open_trades))
    with col4:
        unique_symbols = trades_df['symbol'].nunique()
        st.metric("Unique Symbols", unique_symbols)

    st.write("### File Information")
    if os.path.exists(TRADES_FILE):
        file_size = os.path.getsize(TRADES_FILE)
        mod_time = datetime.fromtimestamp(os.path.getmtime(TRADES_FILE))
        st.write(f"**Main Data File:** {TRADES_FILE}")
        st.write(f"**File Size:** {file_size} bytes ({round(file_size/1024, 2)} KB)")
        st.write(f"**Last Modified:** {mod_time.strftime('%Y-%m-%d %H:%M:%S')}")

    st.write("### Data Cleanup")
    trades_df['duplicate_key'] = trades_df.apply(lambda row: f"{row['date']}_{row['symbol']}_{row['entry_price']}", axis=1)
    duplicates = trades_df[trades_df.duplicated('duplicate_key', keep=False)]
    if not duplicates.empty:
        st.warning(f"Found {len(duplicates)} potential duplicate trades.")
        if st.button("Remove Duplicates"):
            cleaned_df = trades_df.drop_duplicates('duplicate_key', keep='first')
            cleaned_df = cleaned_df.drop('duplicate_key', axis=1)
            save_trades(cleaned_df)
            st.success("Duplicates removed successfully!")
            st.rerun()
    else:
        st.success("No duplicates found.")

    if 'duplicate_key' in trades_df.columns:
        trades_df = trades_df.drop('duplicate_key', axis=1)

    st.write("### Reset Data")
    st.warning("‚ö†Ô∏è This will permanently delete all trades!")
    if st.checkbox("I understand this action cannot be undone", key="reset_confirm"):
        if st.button("Reset All Data"):
            try:
                backup_path = create_backup()
                st.info(f"Backup created: {os.path.basename(backup_path)}")
                empty_df = pd.DataFrame(columns=[
                    "date", "symbol", "strategy", "entry_price", "exit_price", "quantity", "pnl", "notes", "status"
                ])
                save_trades(empty_df)
                st.success("All data has been reset!")
                st.rerun()
            except Exception as e:
                st.error(f"Error resetting data: {str(e)}")

def display_settings_section() -> None:
    """
    Settings UI.
    """
    st.subheader("‚öôÔ∏è Settings")
    config = load_config()

    currency = st.selectbox(
        "Currency",
        ["USD", "EUR", "GBP", "JPY", "CAD", "AUD"],
        index=["USD", "EUR", "GBP", "JPY", "CAD", "AUD"].index(config.get("currency", "USD"))
    )

    date_format = st.selectbox(
        "Date Format",
        ["YYYY-MM-DD", "DD/MM/YYYY", "MM/DD/YYYY"],
        index=["YYYY-MM-DD", "DD/MM/YYYY", "MM/DD/YYYY"].index(config.get("date_format", "YYYY-MM-DD"))
    )

    default_strategy = st.selectbox(
        "Default Strategy",
        STRATEGY_OPTIONS,
        index=STRATEGY_OPTIONS.index(config.get("default_strategy", "Long Stock"))
    )

    theme = st.selectbox(
        "Theme",
        ["light", "dark"],
        index=["light", "dark"].index(config.get("theme", "light"))
    )

    auto_save_interval = st.slider(
        "Auto-save Interval (seconds)",
        min_value=30,
        max_value=3600,
        value=config.get("auto_save_interval", 300),
        step=30
    )

    backup_enabled = st.checkbox(
        "Enable Automatic Backups",
        value=config.get("backup_enabled", True)
    )

    if st.button("Save Settings"):
        new_config = {
            "currency": currency,
            "date_format": date_format,
            "default_strategy": default_strategy,
            "theme": theme,
            "auto_save_interval": auto_save_interval,
            "backup_enabled": backup_enabled,
        }
        try:
            save_config(new_config)
            st.success("Settings saved successfully!")
            st.rerun()
        except Exception as e:
            st.error(f"Error saving settings: {str(e)}")

def display_help_section() -> None:
    """
    Help UI.
    """
    st.subheader("‚ùì Help")
    st.write("### Getting Started")
    st.write("""
1. **Add a Trade**: Click the "‚ûï Add New Trade" button in the sidebar to manually enter trade details.
2. **Import Trades**: Click the "üìÅ Import CSV" button to import trades from a CSV file.
3. **View Performance**: Use the filters in the sidebar to narrow down your trades, then view the charts and metrics.
4. **Export Data**: Click the "üíæ Export Data" button to export your trades or create backups.
5. **Manage Data**: Use the "‚öôÔ∏è Data Management" section to clean up duplicates or reset your data.
""")
    st.write("### Keyboard Shortcuts")
    st.write("""
- **Ctrl + Shift + A**: Toggle Add New Trade form
- **Ctrl + Shift + I**: Toggle Import CSV form
- **Ctrl + Shift + E**: Toggle Export Data form
- **Ctrl + Shift + M**: Toggle Data Management form
- **Ctrl + Shift + S**: Toggle Settings form
- **Ctrl + Shift + H**: Toggle Help form
""")
    st.write("### Data Format for CSV Import")
    st.write("""
When importing trades from CSV, ensure your file has the following columns:
- **date**: Trade date in YYYY-MM-DD format
- **symbol**: Stock ticker symbol (e.g., AAPL)
- **strategy**: Trading strategy (must match predefined options)
- **entry_price**: Price at which the position was entered (credit for option sellers; debit for buyers)
- **exit_price**: Price at which the position was closed (debit for option sellers; credit for buyers; 0 if expired/left open)
- **quantity**: Number of shares/contracts (contracts for options)
- **notes**: Optional notes about the trade
- **status**: Open or Closed
""")
    st.write("### Troubleshooting")
    st.write("""
- **Import fails**: Check that your CSV file has the required columns and correct data types.
- **Charts not showing**: Ensure some trades are marked Closed so realized P&L charts can render.
- **Data not saving**: Check write permissions in the application directory.
- **Performance issues**: Use filters to reduce data volume for large datasets.
""")

# ---------------------------
# Main
# ---------------------------

def main():
    """Main application function."""
    # Load configuration first; then set page config before any output
    _ = load_config()
    st.set_page_config(page_title="Simple Trading Journal", page_icon="üìä", layout="wide")

    st.title("üìä Simple Trading Journal")

    # Init UI toggles
    for key in ("show_form", "show_import", "show_export", "show_management", "show_settings", "show_help"):
        if key not in st.session_state:
            st.session_state[key] = False

    # Load trades
    try:
        trades_df = load_trades()
    except StorageError as e:
        st.error(f"Error loading trades: {str(e)}")
        trades_df = pd.DataFrame(columns=[
            "date", "symbol", "strategy", "entry_price",
            "exit_price", "quantity", "pnl", "notes", "status"
        ])

    # Sidebar controls
    with st.sidebar:
        st.header("Controls")
        if st.button("‚ûï Add New Trade"):
            st.session_state.show_form = not st.session_state.show_form
        if st.button("üìÅ Import CSV"):
            st.session_state.show_import = not st.session_state.show_import
        if st.button("üíæ Export Data"):
            st.session_state.show_export = not st.session_state.show_export
        if st.button("‚öôÔ∏è Data Management"):
            st.session_state.show_management = not st.session_state.show_management
        if st.button("‚öôÔ∏è Settings"):
            st.session_state.show_settings = not st.session_state.show_settings
        if st.button("‚ùì Help"):
            st.session_state.show_help = not st.session_state.show_help

    # Filters
    filter_config = create_filter_sidebar(trades_df)
    filtered_trades_df = filter_trades(trades_df, filter_config)

    # Add trade form
    if st.session_state.show_form:
        with st.expander("‚ûï Add New Trade", expanded=True):
            with st.form("add_trade_form"):
                col1, col2, col3 = st.columns(3)
                with col1:
                    date = st.date_input("Date", value=datetime.now().date())
                    symbol = st.text_input("Symbol")
                    config = load_config()
                    strategy = st.selectbox(
                        "Strategy", STRATEGY_OPTIONS,
                        index=STRATEGY_OPTIONS.index(config.get("default_strategy", "Long Stock"))
                    )
                with col2:
                    entry_price = st.number_input("Entry Price", min_value=0.0, step=0.01)
                    exit_price = st.number_input("Exit Price (0 for open or expired)", min_value=0.0, step=0.01, value=0.0)
                    quantity = st.number_input("Quantity (shares or contracts)", value=1)
                with col3:
                    notes = st.text_area("Notes")
                    closed_flag = st.checkbox("Mark trade as Closed", value=(exit_price > 0))

                # Helper hints for option premiums
                if strategy == "Cash Secured Put":
                    st.info("For CSP: Entry = premium received; Exit = premium paid to close (0 if expired worthless).")
                elif strategy == "Covered Call":
                    st.info("For Covered Call: Entry = premium received; Exit = premium paid to close (0 if expired worthless).")
                elif strategy in ["Long Put", "Long Call"]:
                    st.info("For Long options: Entry = premium paid; Exit = premium received on sale (0 if expired worthless).")

                submitted = st.form_submit_button("Add Trade")
                if submitted:
                    trade_data = {
                        "date": date.strftime("%Y-%m-%d"),
                        "symbol": symbol.upper(),
                        "strategy": strategy,
                        "entry_price": float(entry_price),
                        "exit_price": float(exit_price),
                        "quantity": int(quantity),
                        "notes": notes,
                        "status": "Closed" if closed_flag else "Open",
                    }
                    try:
                        add_trade(trade_data)
                        st.success("Trade added successfully!")
                        st.session_state.show_form = False
                        st.rerun()
                    except TradeValidationError as e:
                        st.error(f"Validation error: {str(e)}")
                    except StorageError as e:
                        st.error(f"Storage error: {str(e)}")
                    except Exception as e:
                        st.error(f"Error adding trade: {str(e)}")

    # Import/export/management/settings/help sections
    if st.session_state.show_import:
        with st.expander("üìÅ CSV Import", expanded=True):
            display_import_section()

    if st.session_state.show_export:
        with st.expander("üíæ Export Data", expanded=True):
            display_export_section(trades_df, filtered_trades_df)

    if st.session_state.show_management:
        with st.expander("‚öôÔ∏è Data Management", expanded=True):
            display_data_management_section(trades_df)

    if st.session_state.show_settings:
        with st.expander("‚öôÔ∏è Settings", expanded=True):
            display_settings_section()

    if st.session_state.show_help:
        with st.expander("‚ùì Help", expanded=True):
            display_help_section()

    if len(filtered_trades_df) != len(trades_df):
        st.info(f"Showing {len(filtered_trades_df)} of {len(trades_df)} trades based on active filters")

    # Charts
    display_charts(filtered_trades_df)

    # Quick stats
    stats = get_summary_stats(filtered_trades_df)
    st.subheader("üìà Quick Stats")
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.metric("Total P&L", f"${stats['total_pnl']:.2f}")
    with col2:
        st.metric("Win Rate", f"{stats['win_rate']:.1%}")
    with col3:
        st.metric("Total Trades", stats['total_trades'])
    with col4:
        st.metric("Avg Trade", f"${stats['avg_trade']:.2f}")

    # Trade history
    st.subheader("üìã Trade History")
    if filtered_trades_df.empty:
        st.info("No trades match the current filters. Try adjusting your filter settings.")
    else:
        edited_df = st.data_editor(
            filtered_trades_df,
            use_container_width=True,
            num_rows="dynamic",
            column_config={
                "date": st.column_config.TextColumn("Date"),
                "entry_price": st.column_config.NumberColumn("Entry Price", format="$%.2f"),
                "exit_price": st.column_config.NumberColumn("Exit Price", format="$%.2f"),
                "pnl": st.column_config.NumberColumn("P&L", format="$%.2f"),
            }
        )
        if not edited_df.equals(filtered_trades_df):
            try:
                save_trades(edited_df)
                st.success("Changes saved!")
                st.rerun()
            except StorageError as e:
                st.error(f"Error saving changes: {str(e)}")

if __name__ == "__main__":
    main()
